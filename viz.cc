// Playing around with measure data
// generated by https://github.com/FOULAB/Project-COGSWORTH/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <math.h>
#include <stdint.h>

#include "colormaps.h"

RGBFloatCol *const colormap = kMagmaColors;  // see colormaps.h for choice

static int usage(const char *prog) {
    fprintf(stderr, "Usage: %s <filename-pattern> <width> <height>\n", prog);
    fprintf(stderr, "Output is written to stdout\n");
    fprintf(stderr, "Example:\n"
            "%s SAMPLE_3162099_%%03d-%%03d.dmp 200 70 > foo.pnm\n",
            prog);
    return 1;
}

int main(int argc, char *argv[]) {
    if (argc != 4) return usage(argv[0]);
    const char *pattern = argv[1];
    const int w = atoi(argv[2]);
    const int h = atoi(argv[3]);
    int out_fd = STDOUT_FILENO;

    // Let's first determine the range of values, before we flatten it
    // to a 256 image
    float min_value = 1e6, max_value = -1e6;
    float *raw_image = (float*) calloc(w * h, sizeof(float));
    int64_t total_data_read = 0;

    char filename[256];
    struct stat statbuf;
    for (int x = 0; x < w; ++x) {
        for (int y = 0; y < h; ++y) {
            snprintf(filename, sizeof(filename), pattern, x, y);
            const int fd = open(filename, O_RDONLY);

            // Little bit of sanity checking.
            if (fd < 0 ||
                fstat(fd, &statbuf) < 0 ||
                statbuf.st_size % sizeof(float) != 0) {
                fprintf(stderr, "%s: %s\n", filename, strerror(errno));
                close(fd);
                continue;
            }

            fprintf(stderr, "\b\b\b\b\b\b\b%03d %03d", x, y);
            float *values = (float*) mmap(NULL, statbuf.st_size, PROT_READ,
                                          MAP_SHARED, fd, 0);
            if (values == NULL) {
                fprintf(stderr, "Couldn't map %s; %s\n", filename, strerror(errno));
                continue;
            }
            // Let's determine the average of the measurement at a 'pixel'
            float sum = 0.0;
            float count = statbuf.st_size / sizeof(float);
            for (int i = 0; i < count; ++i)
                sum += values[i];
            munmap(values, statbuf.st_size);
            total_data_read += statbuf.st_size;
            close(fd);

            int ypos = x % 2 == 0 ? y : h - y - 1;  // Scanning goes up/down
            int xpos = w - x - 1;                   // scanning right2left
            float avg = sum / count;
            raw_image[ypos * w + xpos] = avg;
            if (avg < min_value) min_value = avg;
            if (avg > max_value) max_value = avg;
        }
    }

    fprintf(stderr, "\nSeen range from %.3f .. %.3f. Processed %.2f Mbytes\n",
            min_value, max_value, total_data_read / 1024.0 / 1024.0);

    // Dump out the PNM image.
    dprintf(out_fd, "P6\n%d %d\n255\n", w, h);
    const float scale = 255 / (max_value - min_value);
    for (int y = 0; y < h; ++y) {
        for (int x = 0; x < w; ++x) {
            float raw = raw_image[y * w + x];
            int val = (raw < min_value) ? 0 : round((raw - min_value) * scale);
            const RGBFloatCol &c = colormap[val];
            unsigned char col_bits[3] = { (unsigned char) lround(c.r * 255),
                                          (unsigned char) lround(c.g * 255),
                                          (unsigned char) lround(c.b * 255)};
            write(out_fd, col_bits, 3);
        }
    }
    free(raw_image);
}
